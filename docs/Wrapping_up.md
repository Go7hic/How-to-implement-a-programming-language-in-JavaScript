## Wrapping up

为了真正完成本书的操作方法，我继续前进并添加了一些（不是必需的，但必须具备的）功能和修复λ语言的功能，而未在此处描述它们的实现。 下载下面的完整代码。

该程序可通过NodeJS运行。 它从STDIN中以λ语言读取程序并编译并执行。 它在STDERR处产生编译结果，并在STDOUT处产生程序输出。 用法示例：
```
cat primitives.lambda program.lambda | node lambda.js
```

#### The final touches are:

- 支持否定运算符（！）。 这不是必需的，因为它可以很容易地实现为一个函数：

```
not = λ(x) if x then false else true;
not(1 < 0)        # ⇒ true
```

- 然而，为它提供一个专用的AST节点允许我们生成更有效的代码(函数调用意味着GUARD-s等)。
我添加了一个js：raw关键字。 使用它，您可以在输出中插入任意JavaScript代码（仅完整表达式，而不是语句）。 用例示例是从λ语言轻松定义基元：
```
length = js:raw "function(k, thing){
  k(thing.length);
}";

arrayRef = js:raw "function(k, array, index){
  k(array[index]);
}";

arraySet = js:raw "function(k, array, index, newValue){
  k(array[index] = newValue);
}";

array = js:raw "function(k){
  k([].slice.call(arguments, 1));
}";
```
我将语法荧光笔配置为对该关键字使用带红色的颜色，因为这很危险。 也许不尽然，但是您必须知道使用它的含义：传递给js：raw的代码将使其保持不变并未经检查而进入输出JS。 例如，优化器将无法看到您正在访问下面的局部变量，它将删除x = 10：
```
dumb = λ() {
  let (x = 10) js:raw "x + x";
};
→	
dumb = function(β_K1) {
  β_K1(x + x);
};
```

那不是错误。 应该发生的。
- 为布尔表达式生成更好的代码-如我们所写，make_js可以轻松生成类似（a <0？true：false）！== false的输出，但显然可以简化为<0。这可能不会 增加速度，但至少输出代码看起来不那么愚蠢。
- 修复了&&和||的语义 运算符，例如false是我们语言中唯一的虚假值。
- 它为全局变量生成var声明，并在“ use strict”下评估最终代码（在严格模式下，速度提高了5-10％）。

#### 我们甚至接近一种真实的语言吗？

信不信由你，λ语言非常接近Scheme。 我向您保证我们不会实施Lisp，我信守诺言。 但是大部分工作已经完成：我们拥有不错的CPS变压器和优化器。 如果我们想实现Scheme，剩下的就是编写一个Scheme解析器，该解析器生成兼容的AST，并向宏扩展传递预编译器。 还有一堆用于核心库的原语。 那不应该是太多的工作。

#### TODO

如果我们想继续研究λ语言，那么应该注意以下几点。
 
- 变量名

JavaScript生成器将变量名保留为原样，但这通常不是一个好主意（更不用说这是一个普通的错误，因为我们在标识符名称中允许使用JavaScript不允许的字符）。 我们至少应该在全局变量前添加前缀并替换非法字符。 我正在考虑的前缀是“λ_”。

- 变量参数列表

任何实用的语言都需要类似JavaScript的参数。 我们可以轻松地为其添加一些语法，例如：
```
foo = λ(first, second, rest...) {
  ## rest here is an array with arguments after second
};
```

但是等等，我们的λ语言中还有什么数组？ （在列表的下一个）。

似乎很容易想到我们已经可以使用“参数”名称（因为我们在JS中保留了相同的变量名称），但是这种方式无法正常工作：to_cps和优化器都将假定它是一个全局的，可能会导致混乱 。

要在不牺牲太多代码大小的情况下实现上述语法，我们可以使用GUARD函数。 输出示例：
```
foo = function CC(first, second) {
  var rest = GUARD(arguments, CC, 2); // returns arguments starting at index 2
};
```
与此功能相关，我们还需要等效于Function.prototype.apply。

- 数组和对象

就像我们上面的js：raw一样，这些很容易定义为原始函数。 但是，在语法级别实现它们将允许生成更有效的代码，并为我们提供熟悉的语法。 a [0] = 1无疑比arraySet（a，0，1）好。

我想避免的一件事是模棱两可。 例如，在JavaScript中，大括号用于表示代码主体和文字对象。 规则是“在语句位置出现大括号时，这是一个代码块； 在表达式位置时，它是对象文字。” 但是我们没有λ语言的语句（这实际上是一个功能），大括号表示一系列表达式。 我想保持这种方式，所以我不会在对象文字中使用{...}表示法。

- “点”符号

与上一个相关，我们应该支持点符号来访问对象属性。 这太普遍了，不容忽视。

我希望像JavaScript一样支持“方法”在某种程度上具有挑战性（即this关键字）。 这样做的原因是我们所有的函数都转换为CPS（并且所有函数调用都会将延续作为第一个参数插入）。 如果我们要支持类似JS的方法，我们怎么知道我们正在CPS中调用一个函数（即用λ语言编写）而不是一个直接函数（即从某个JS库中）？ 这需要一些思考。

- 语法(分隔符)
在“ prog”节点中用分号分隔表达式的要求有点太严格了。 例如，根据当前的解析器规则，以下语句在语法上无效：
```
if foo() {
  bar()
}                  # ← error
print("DONE")
```
问题在标记线上。即使它以一个右花括号结束，它后面也应该有一个分号(因为if实际上是一个表达式，并且它以那个右括号结束)。这在JavaScript中不是很直观;放松规则，在以花括号结束的表达式后面设置分号为可选的，似乎是更好的选择。但这很棘手，因为下面也是一个有效的程序:
```
a = {
  foo();
  bar();
  fib
}
(6);
```

结果是调用foo（），bar（），然后将fib（6）的结果放入变量a中。 语法很愚蠢，但是您知道，大多数infix语言都会受到这种怪异的困扰，例如，以下语法在语法上是有效的JS程序； 如果尝试，则不会出现解析错误，尽管在调用foo（）时显然会出现运行时错误：
```
function foo() {
  a = {
    foo: 1,
    bar: 2,
    baz: 3
  }
  (10);
}
```
 
- 例外情况

我们可以在重置和移位运算符或其他原语之上提供异常系统。

### 继续…

即使没有TODO 中列出的功能，我们的λ语言也非常强大，我将以一些示例结束本文，比较一些示例如何在NodeJS和λ语言中实现琐碎的程序。 